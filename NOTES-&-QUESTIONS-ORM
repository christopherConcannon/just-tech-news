ORM -- OBJECT RELATIONAL MAPPING


The biggest benefit that an ORM like Sequelize offers is sparing us from spending a lot of time writing SQL to define our tables and queries. Instead, we can use object-oriented concepts to model our database tables using JavaScript classes. This lets us add validators and custom rules to the SQL data where SQL sometimes falls short.


KEEPING SENSITIVE DATA SECURE -- DEVELOPMENT VARIABLES
what we can do is set up local environment variables for development, then use the production environment variables when we deploy to Heroku. This means that our sensitive data will not be exposed when we push to GitHub!

To do this, we'll need to install another NPM package called dotenv. From the command line, run the following code:

npm install dotenv

Once that's installed, at the root of your application create a file called .env and add the following code:

DB_NAME='just_tech_news_db'
DB_USER='your-mysql-username'
DB_PW='your-mysql-password'
That's all you have to do to set up these environment variables. Next, load them into the connection.js file. Let's update that file to look like the following code:

const Sequelize = require('sequelize');

require('dotenv').config();

// create connection to our db
const sequelize = new Sequelize(process.env.DB_NAME, process.env.DB_USER, process.env.DB_PW, {
  host: 'localhost',
  dialect: 'mysql',
  port: 3306
});

module.exports = sequelize;
Notice how we don't have to save the require('dotenv') to a variable? All we need it to do here is execute when we use connection.js and all of the data in the .env file will be made available at process.env.<ENVIRONMENT-VARIABLE-NAME>.

Remember to add .env to your .gitignore file.



SEQUELIZE - ORM


When we learned about JavaScript constructors and classes, we also learned how to make the application's dataflow consistent when we create a blueprint of how certain data should look and be interacted with. When we create a SQL table, we perform a similar action. We provide names for what columns the data will go into and what types of data we expect for that column.

Sequelize goes a step further by taking object-oriented JavaScript concepts and applying them to how we set up the SQL tables. This is done by using Sequelize's model class where, essentially, we create our own JavaScript class and define the columns, data types, and any other rules we need the data to adhere to.

This class will serve as a layer between the API and the database and will handle all transactions of data between the two. As we'll see, it'll provide a lot more flexibility and functionality that we would otherwise have to create on our own


STEPS

Model the data.

Set up API routes to work with that data.

Test the routes to make sure everything works as intended.

Repeat with new model.


CREATE LOGIN ROUTE -- PROTECTING USER DATA

An application's first interaction with a user's password occurs the moment that user creates an account. At that time, we must intervene and hash the plaintext password before it is stored in the database.

Hashing performs a one-way transformation on a password, turning the password into another string, called the hashed password. 'One-way' means that it is practically impossible to go the other wayâ€”to turn the hashed password back into the original password."

We'll use a node package called bcrypt to perform the hashing function. We could've chosen other alternatives, but bcrypt has a proven, consistent track record of security. Its popularity and adoption by different computer languages further underscores its value.


At the root directory, install bcrypt, as shown in the following code:

npm install bcrypt

Next, import bcrypt into the User.js file by adding the require expression at the top of the file, as shown in the following code:

const bcrypt = require('bcrypt');

Now that the User model has access to bcrypt, how do we use it to hash the password?

According to the bcrypt page on npm, we can use the hash function. (Links to an external site.)

The documentation recommends using an async function. Let's choose one that will return the hashed password in a Promise, as shown in the following image:

The hash method from bcrypt will return a hashed password.

This method will autogenerate a salt. Notice the saltRounds parameter. This is known as the cost factor and controls how many rounds of hashing are done by the bcrypt algorithm. The more hashing rounds, the longer it takes to hash, the more time it would take to crack using a brute-force attack.

where can we use this function in the course of the application? In other words, how do we inject this logic to occur just before a user is created?

Thankfully, we can use special Sequelize functions called hooks in the model. Also known as lifecycle events, hooks are functions that are called before or after calls in Sequelize.

According to the Sequelize documents, to use hooks, we must pass in another object labelled hooks to the User.init() function.



hooks: {
  // set up beforeCreate lifecycle "hook" functionality
  beforeCreate(userData) {
    return bcrypt.hash(userData.password, 10).then(newUserData => {
      return newUserData
    });
  }
}
Let's break down this code to see what is happening. We use the beforeCreate() hook to execute the bcrypt hash function on the plaintext password. In the bcrypt hash function, we pass in the userData object that contains the plaintext password in the password property. We also pass in a saltRound value of 10.

The resulting hashed password is then passed to the Promise object as a newUserData object with a hashed password property. The return statement then exits out of the function, returning the hashed password in the newUserData function.

That seems a bit complex for such a simple async function. Notice how we needed to create two different local variables, userData and newUserData? It's a bit clunky and hard to follow due to the two variables that store the pre-hash and post-hash data, userData and newUserData, respectively.

ASYNC/AWAIT

Good thing there is another method to handle async functions that will make the code more concise and legible. We will use the async/await syntax to replace the Promise.

Let's replace the function above using Promises with the new version of the exact same functionality with the async/await syntax, as shown in the code below:

hooks: {
  // set up beforeCreate lifecycle "hook" functionality
  async beforeCreate(newUserData) {
    newUserData.password = await bcrypt.hash(newUserData.password, 10);
    return newUserData;
  },
}
The keyword pair, async/await, works in tandem to make this async function look more like a regular synchronous function expression.

The async keyword is used as a prefix to the function that contains the asynchronous function. await can be used to prefix the async function, which will then gracefully assign the value from the response to the newUserData's password property. The newUserData is then returned to the application with the hashed password.

Comparing these two functions side by side, we can see that the async/await version is much easier to read with only a single newUserData variable that is input and output after the password hashing modification. Now the async function looks like a plain old JavaScript expression.



LOGIN 
The next step in this application is to create the login route that will verify the user's identity.

We cannot use the current GET route that retrieves a single user using the req.params.id. This route will query the database for a single user, as the query is based on the user id, which is unknown to users.

To log in to a user's account, we'll verify the user's identity using the user's email address and password. We could've used the username, but email is a unique identifier and preferred in case there are duplicate usernames.


First, go to the user-routes.js file in the routes/api folder. Beneath the POST route that creates a new user, add the following login route:

router.post('/login', (req, res) => {

  // Query operation

})
This route will be found at http://localhost:3001/api/users/login in the browser.

In this case, a login route could've used the GET method since it doesn't actually create or insert anything into the database. But there is a reason why a POST is the standard for the login that's in process.

A GET method carries the request parameter appended in the URL string, whereas a POST method carries the request parameter in req.body, which makes it a more secure way of transferring data from the client to the server. Remember, the password is still in plaintext, which makes this transmission process a vulnerable link in the chain.

Now that we know which HTTP method we'll use, let's think about the query itself.

The first step will be to find the instance of a user that contains the user's credentials. In this case, it will be the user's email. If the email isn't found, there's no need to try and verify the password since this user account doesn't exist in the database.

However, if the user's email is in the database, this instance of a user must be returned in a Promise so we can proceed with the password verification process.

Add the following code; we'll examine what it does afterwards:

router.post('/login', (req, res) => {
// expects {email: 'lernantino@gmail.com', password: 'password1234'}
  User.findOne({
    where: {
      email: req.body.email
    }
  }).then(dbUserData => {
    if (!dbUserData) {
      res.status(400).json({ message: 'No user with that email address!' });
      return;
    }

    res.json({ user: dbUserData });

    // Verify user

  });  
});
Here's what we're doing in the preceding code. We queried the User table using the findOne() method for the email entered by the user and assigned it to req.body.email.

If the user with that email was not found, a message is sent back as a response to the client. However, if the email was found in the database, the next step will be to verify the user's identity by matching the password from the user and the hashed password in the database. This will be done in the Promise of the query.


Compare the Hashed Password
We'll want to use bcrypt again to compare a plaintext password to its encrypted form. See if you can find the right bcrypt methods by consulting its documentation: npm's bcrypt page. (Links to an external site.)

The documentation has a Check a Password section. The bcrypt package offers an async method called compare that takes in two parameters: the plaintext password from the user and the hashed password from the database. Then the function compares them. If they match, true is returned. If they don't, false is returned.

The bcrypt package also offers a sync version, .compareSync(), that operates on the same principles. Notice the following section of the documentation:

Why is async mode recommended over sync mode?

If you are using bcrypt on a simple script, using the sync mode is perfectly fine. However, if you are using bcrypt on a server, the async mode is recommended. This is because the hashing done by bcrypt is CPU intensive, so the sync version will block the event loop and prevent your application from servicing any other inbound requests or events. The async version uses a thread pool which does not block the main event loop.
So, for a better user experience on a live app, choose the async version to reduce the time a user has to wait to verify the password. Here, however, we're going to use the sync version, just to expedite test development:


We now know how to verify a user's password by comparing the plaintext and the hashed password versions. How do we incorporate this step in the application?

We'll need an instance method.

In Object Oriented Programming, an instance method returns or makes use of information (i.e., properties) specific to that particular object. (Remember that objects generated from classes are instances of the class.)

So, we should create an instance method on the User model definition to access the password property of each user instance. To do this, let's navigate back to the User model in the User.js file.

Let's modify the User to include an instance method called checkPassword that takes in the plaintext password retrieved from the client request at req.body.email and compares that with the hashed password. This method will include the compareSync function from bcrypt, as shown in the following code:

// create our User model
class User extends Model {
  // set up method to run on instance data (per user) to check password
  checkPassword(loginPw) {
    return bcrypt.compareSync(loginPw, this.password);
  }
}
Using the keyword this, we can access this user's properties, including the password, which was stored as a hashed string.

Now that we have the instance method in place, let's return to look at the code in the /login route in user-routes.js.

The .findOne() Sequelize method looks for a user with the specified email. The result of the query is passed as dbUserData to the .then() part of the .findOne() method. If the query result is successful (i.e., not empty), we can call .checkPassword(), which will be on the dbUserData object. We'll need to pass the plaintext password, which is stored in req.body.password, into .checkPassword() as the argument.

The .compareSync() method, which is inside the .checkPassword() method, can then confirm or deny that the supplied password matches the hashed password stored on the object. .checkPassword() will then return true on success or false on failure. We'll store that boolean value to the variable validPassword.

So, let's start by adding the following expression inside the .then() portion of .findOne(), right after // Verify user:

const validPassword = dbUserData.checkPassword(req.body.password);
Note that the instance method was called on the user retrieved from the database, dbUserData. Because the instance method returns a Boolean, we can use it in a conditional statement to verify whether the user has been verified or not. Add the following control statement below the const validPassword definition:

if (!validPassword) {
  res.status(400).json({ message: 'Incorrect password!' });
  return;
}

res.json({ user: dbUserData, message: 'You are now logged in!' });
In the conditional statement above, if the match returns a false value, an error message is sent back to the client, and the return statement exits out of the function immediately.

However, if there is a match, the conditional statement block is ignored, and a response with the data and the message "You are now logged in." is sent instead.

The /login route should now resemble the following code:

router.post('/login', (req, res) => {
  // expects {email: 'lernantino@gmail.com', password: 'password1234'}
  User.findOne({
    where: {
      email: req.body.email
    }
  }).then(dbUserData => {
    if (!dbUserData) {
      res.status(400).json({ message: 'No user with that email address!' });
      return;
    }

    const validPassword = dbUserData.checkPassword(req.body.password);
    if (!validPassword) {
      res.status(400).json({ message: 'Incorrect password!' });
      return;
    }

    res.json({ user: dbUserData, message: 'You are now logged in!' });
  });
});


WHAT IS A MODEL?
.when setting up Sequelize to work with the database, we write models, somtimes known as schemas to construct the tables that we'll use.  using has the following benefits: 
    --auto-building of tables so that we don't need to write SQL queries to do this manually
    --data validation and restriction
    --creating relationships between data, plus it's all written in JS

.by default Sequelize creates 2 additional columns...createdAt and updatedAt which can be useful for our applications



WORKFLOW
seasoned developers would argue that it makes more sense to build each section of the app at a time to lessen the cognitive jumping around. For instance, creating all the models at once could help inform the data associations and relationships better. This makes a degree of sense due to the fact that much of the code between these files is quite similar. The same goes for the routes.